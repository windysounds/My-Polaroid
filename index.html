<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polaroid Photo Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Caveat:wght@400;600&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Arial', sans-serif; background: linear-gradient(135deg, #2c1810 0%, #1a0f0a 100%); min-height: 100vh; overflow-x: hidden; color: #f5f5f5; }
        
        /* (중략) ... 다른 CSS 코드는 이전과 동일 ... */

        /* 🛠️ 해결책 1: CSS 필터에 WebKit 접두사 추가하여 Safari 호환성 확보 */
        .filter-film { 
            -webkit-filter: contrast(1.35) brightness(1.05) saturate(0.65) sepia(0.35) hue-rotate(15deg) blur(0.3px);
            filter: contrast(1.35) brightness(1.05) saturate(0.65) sepia(0.35) hue-rotate(15deg) blur(0.3px);
            position: relative;
        }
        
        .filter-retro { 
            -webkit-filter: grayscale(1) contrast(1.4) brightness(0.85) saturate(0);
            filter: grayscale(1) contrast(1.4) brightness(0.85) saturate(0); 
        }
        
        /* (중략) ... 나머지 CSS 코드는 이전과 동일 ... */
        .filter-none { filter: none; }
        .flash-effect { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(255,240,200,0.6) 100%); opacity: 0; pointer-events: none; z-index: 9999; }
        .export-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 1000; justify-content: center; align-items: center; cursor: pointer; }
        .export-content { position: relative; background: linear-gradient(135deg, #2c1810, #1a0f0a); padding: 40px; border-radius: 15px; text-align: center; max-width: 450px; width: 90%; box-shadow: 0 20px 60px rgba(0,0,0,0.8); border: 1px solid rgba(212, 165, 116, 0.2); cursor: default; }
        .export-content h3 { color: #d4a574; margin-bottom: 20px; font-size: 20px; }
        .export-polaroid { width: 220px; height: 275px; background: #fefefe; border-radius: 3px; box-shadow: 0 8px 25px rgba(0,0,0,0.6); padding: 18px 18px 45px 18px; margin: 20px auto; position: relative; }
        .export-image { width: 100%; height: 184px; object-fit: cover; border-radius: 2px; }
        .export-text { position: absolute; bottom: 18px; left: 18px; right: 18px; text-align: center; font-family: 'Caveat', cursive; font-size: 16px; font-weight: 600; color: #333; transform: rotate(-1deg); }
        .filter-options { display: flex; justify-content: center; gap: 10px; margin: 20px 0; flex-wrap: wrap; }
        .filter-btn { padding: 8px 16px; border: 2px solid #d4a574; background: transparent; color: #d4a574; border-radius: 20px; cursor: pointer; font-size: 12px; font-weight: 600; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 1px; }
        .filter-btn:hover { background: rgba(212, 165, 116, 0.2); transform: translateY(-2px); }
        .filter-btn.active { background: #d4a574; color: #1a0f0a; }
        .export-buttons { margin-top: 25px; display: flex; justify-content: center; align-items: center; gap: 10px; flex-wrap: wrap; }
        .btn { padding: 12px 24px; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 1px; }
    </style>
</head>
<body>
    <!-- (HTML 구조는 변경 없음) -->
    <div class="flash-effect"></div>
    <div class="container">
        <div class="upload-section" id="uploadSection">
            <div class="polaroid-frame" id="polaroidFrame">
                <div class="photo-area" id="photoArea">
                    <div class="upload-placeholder">
                        <div class="upload-icon">+</div>
                        <div class="upload-text">Click to upload photo</div>
                    </div>
                </div>
                <div class="text-area">
                    <input type="text" class="photo-text" id="photoText" placeholder="Write a caption...">
                </div>
            </div>
            <div class="shutter-button" id="shutterButton"></div>
            <input type="file" class="file-input" id="fileInput" accept="image/*">
        </div>
    </div>
    
    <div class="gallery-section">
        <div class="clothesline">
            <div class="clothesline-wire"></div>
            <div class="gallery-container" id="galleryContainer">
                <div class="saved-polaroids" id="savedPolaroids"></div>
            </div>
        </div>
    </div>
    
    <div class="export-modal" id="exportModal">
        <div class="export-content">
            <h3>Export Polaroid</h3>
            <div class="export-polaroid" id="exportPolaroid">
                <img class="export-image" id="exportImage">
                <div class="export-text" id="exportText"></div>
            </div>
            <div class="filter-options">
                <button class="filter-btn active" data-filter="film">Film</button>
                <button class="filter-btn" data-filter="retro">B&W</button>
                <button class="filter-btn" data-filter="none">Original</button>
            </div>
            <div class="export-buttons">
                <button class="btn btn-primary" id="downloadBtn">Download</button>
                <button class="btn btn-secondary" id="cancelBtn">Cancel</button>
            </div>
            <button id="deleteIconBtn">🗑️</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // (상단 변수 선언 및 IndexedDB 함수는 변경 없음)
            let db;
            let savedPhotos = []; 
            let currentImage = null, currentExportPhoto = null, currentFilter = 'film';
            const photoArea = document.getElementById('photoArea'), fileInput = document.getElementById('fileInput'), shutterButton = document.getElementById('shutterButton'), photoText = document.getElementById('photoText'), polaroidFrame = document.getElementById('polaroidFrame'), savedPolaroids = document.getElementById('savedPolaroids'), flashEffect = document.querySelector('.flash-effect'), exportModal = document.getElementById('exportModal'), exportImage = document.getElementById('exportImage'), exportText = document.getElementById('exportText'), downloadBtn = document.getElementById('downloadBtn'), cancelBtn = document.getElementById('cancelBtn'), deleteIconBtn = document.getElementById('deleteIconBtn'), galleryContainer = document.getElementById('galleryContainer');
            let isDragging = false, startX, scrollLeft, mouseDownPos = {x: 0, y: 0};
            
            // (IndexedDB, 사운드 등 다른 함수들도 변경 없음)
            
            // 🛠️ 해결책 2: Canvas 필터 처리를 위한 새로운 함수
            function applyCanvasFilter(imageData, filterType) {
                const data = imageData.data;
                
                if (filterType === 'film') {
                    // 필름 효과를 픽셀 단위로 직접 처리
                    for (let i = 0; i < data.length; i += 4) {
                        let r = data[i], g = data[i+1], b = data[i+2];
                        
                        // 세피아 톤 적용
                        const tr = Math.min(255, 0.393 * r + 0.769 * g + 0.189 * b);
                        const tg = Math.min(255, 0.349 * r + 0.686 * g + 0.168 * b);
                        const tb = Math.min(255, 0.272 * r + 0.534 * g + 0.131 * b);
                        
                        // 채도와 대비 미세 조정
                        data[i] = tr * 1.1;
                        data[i+1] = tg;
                        data[i+2] = tb * 0.9;
                    }
                } else if (filterType === 'retro') {
                    // 흑백 효과
                    for (let i = 0; i < data.length; i += 4) {
                        const gray = data[i] * 0.299 + data[i+1] * 0.587 + data[i+2] * 0.114;
                        const contrastedGray = 1.2 * (gray - 128) + 128; // 컨트라스트 증가
                        data[i] = data[i+1] = data[i+2] = contrastedGray;
                    }
                }
                
                return imageData;
            }

            // 🛠️ 해결책 2: downloadPolaroid 함수 수정
            function downloadPolaroid() {
                if (!currentExportPhoto) return;
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const scale = 3;
                    const frameWidth = 280 * scale, frameHeight = 350 * scale;
                    const photoWidth = 244 * scale, photoHeight = 245 * scale;
                    const padding = 18 * scale;
                    canvas.width = frameWidth; canvas.height = frameHeight;
                    ctx.fillStyle = '#fefefe'; ctx.fillRect(0, 0, frameWidth, frameHeight);
                    
                    const imgAspectRatio = img.naturalWidth / img.naturalHeight;
                    const photoAspectRatio = photoWidth / photoHeight;
                    let drawWidth, drawHeight, drawX, drawY;
                    if (imgAspectRatio > photoAspectRatio) {
                        drawHeight = photoHeight; drawWidth = drawHeight * imgAspectRatio;
                        drawX = padding + (photoWidth - drawWidth) / 2; drawY = padding;
                    } else {
                        drawWidth = photoWidth; drawHeight = drawWidth / imgAspectRatio;
                        drawX = padding; drawY = padding + (photoHeight - drawHeight) / 2;
                    }
                    
                    ctx.save();
                    ctx.beginPath(); ctx.rect(padding, padding, photoWidth, photoHeight); ctx.clip();
                    ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                    
                    // === 불안정한 ctx.filter 제거하고 수동 필터 적용 로직으로 교체 ===
                    if (currentFilter !== 'none') {
                        const imageData = ctx.getImageData(padding, padding, photoWidth, photoHeight);
                        const filteredData = applyCanvasFilter(imageData, currentFilter);
                        ctx.putImageData(filteredData, padding, padding);
                    }
                    
                    // 노이즈 추가
                    if (currentFilter === 'film' || currentFilter === 'retro') {
                        addNoise(ctx, padding, padding, photoWidth, photoHeight, 20);
                    }
                    
                    ctx.restore();
                    
                    if (currentExportPhoto.text) {
                        const textY = frameHeight - 35 * scale;
                        ctx.save(); ctx.translate(frameWidth / 2, textY); ctx.rotate(-0.017);
                        ctx.fillStyle = '#333'; ctx.font = `600 ${16 * scale}px 'Caveat', cursive`;
                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.fillText(currentExportPhoto.text, 0, 0); ctx.restore();
                    }
                    
                    canvas.toBlob((blob) => {
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.download = `polaroid_${Date.now()}.png`; link.href = url;
                        document.body.appendChild(link); link.click(); document.body.removeChild(link);
                        URL.revokeObjectURL(url);
                        closeExportModal();
                    }, 'image/png');
                };
                img.src = currentExportPhoto.image;
            }

            // (중략) ... 다른 모든 함수는 이전과 동일 ...

            // --- 이벤트 리스너 ---
            photoArea.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileUpload);
            shutterButton.addEventListener('click', handleShutterClick);
            document.querySelectorAll('.filter-btn').forEach(btn => btn.addEventListener('click', handleFilterChange));
            cancelBtn.addEventListener('click', closeExportModal);
            downloadBtn.addEventListener('click', downloadPolaroid);
            deleteIconBtn.addEventListener('click', handleDeleteClick);
            exportModal.addEventListener('click', (e) => { if (e.target === exportModal) closeExportModal(); });
            
            // 기존 마우스 이벤트
            galleryContainer.addEventListener('mousedown', startDrag);
            galleryContainer.addEventListener('mouseup', endDrag);
            galleryContainer.addEventListener('mouseleave', endDrag);
            galleryContainer.addEventListener('mousemove', onDrag);

            // 🛠️ 해결책 3: 모바일 터치 이벤트 추가
            galleryContainer.addEventListener('touchstart', (e) => {
                // 한 번의 드래그를 시작할 때, 클릭 이벤트와의 중복을 막기 위해 플래그를 사용합니다.
                if (isDragging) return;
                const touch = e.touches[0];
                startDrag({ pageX: touch.pageX, clientX: touch.clientX, clientY: touch.clientY, target: e.target });
            }, { passive: false }); // 스크롤 방지를 위해 passive: false 설정

            galleryContainer.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                e.preventDefault(); // 드래그 중 페이지 스크롤 방지
                const touch = e.touches[0];
                onDrag({ pageX: touch.pageX, preventDefault: () => {} });
            }, { passive: false });

            galleryContainer.addEventListener('touchend', (e) => {
                if (!isDragging) return;
                const touch = e.changedTouches[0];
                // touchend 이벤트에는 target 정보가 없으므로, elementFromPoint를 사용합니다.
                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                endDrag({ clientX: touch.clientX, clientY: touch.clientY, target: target });
            });

            async function init() {
                // ... (init 함수는 변경 없음)
                try {
                    await initDB();
                    savedPhotos = await getAllPhotosFromDB();
                    updateGallery();
                } catch (error) {
                    console.error("Initialization failed:", error);
                    alert("Could not initialize database. Saved photos cannot be loaded.");
                }
            }

            init();
        });
    </script>
</body>
</html>
